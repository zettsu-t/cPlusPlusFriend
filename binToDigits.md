# 8-bit符号無し整数の十進数表記

8-bit符号無し整数(0..255)を十進数表記にしたときの、百、十、一の位が何かを求める、という[話題](https://twitter.com/kuina_ch/status/1005039862670479360)がありました。おそらく効率の良いアセンブリコードがあると思いますが、再発明してみましょう。

「ハッカーのたのしみ」的な王道としては、逆数 (1/10) * 掛けられる数の最大値+1 (256)を掛けるというものです。つまりn=0..255に対する百と十の位=n/10を求めるために、本当は25.6を掛けたいのです。代わりに25を掛けて256で割るとどうなるでしょうか。

```text
求めたい n/10 = (n + 1) * 25 / 256
= (10 * i + j + 1) * 25 / 256 : n = 10 * i + j, i = 0..25, j = 0..9
= (250 * i + 25 * j + 25) / 256
= (256 * i + 25 * j + 25 - 6 * i) / 256
= i + (25 * j + 25 - 6 * i) / 256
=> i - 5 / 256 < i at i = 5, j = 0
```
となってしまい、n=50に対して正しい答えを返しません。

実は (n + 1) * 51 / 512とすると、正しくn/10が求まります。これは、以下の式変形で求まります。

```text
求めたい n/10 = (n + 1) * 51 / 512
= (10 * i + j + 1) * 51 / 512 : n = 10 * i + j, i = 0..25, j = 0..9
= (510 * i + 51 * j + 51) / 512
= (512 * i + 51 * j + 51 - 2 * i) / 512
= i + (51 * j + 51 - 2 * (25 - i')) / 512 : i' = 25 - i = 0..25
= i + (1 + 51 * j + 2 * i') / 512
小数点以下を切り捨てると i : なぜなら 1 <= (1 + 51 * j + 2 * i') <= 509 < 512
```

n=255の場合もこの式は成り立ちますが、8-bitレジスタではn=256が0になってしまうのをn=255と読み替える、つまり min(255, (n + 1)) * 51 / 512 とする必要があります。

これでn/10が求まりましたので、n-i*10からnの一の位が求まります。n/10に対しても同様に十の位と一の位を求めればnの百の位と十の位になるので、百、十、一の位つまり十進数表記が求まります。コードは、[cppFriendsSampleAsm.cpp](cppFriendsSampleAsm.cpp)の __TestSplitDigits__ にあります。CPUに乗算命令があればもっとすっきり書けるでしょう。
