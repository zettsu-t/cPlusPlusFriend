---
title: "Pythonプログラマが30分で分かるR"
author: "プログラマたんbot"
date: '`r format(Sys.time(), "%Y/%m/%d")`'
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
  pdf_document:
    latex_engine: xelatex
  beamer_presentation:
    pandoc_args:
    - --latex-engine
    - xelatex
header-includes:
  \usepackage{float}
documentclass: bxjsarticle
classoption: xelatex,ja=standard
urlcolor: blue
---

```{r setup_r_packages, include=FALSE}
library(kableExtra)
library(reticulate)
```

```{r, echo=FALSE, eval=FALSE}
## Windows から Python を起動するには、 .Rprofile にこう書く
## Sys.setenv(PATH=paste0(c("C:\bin\anaconda", Sys.getenv("PATH")), sep="", collapse=";"))

## Windows から cloc 経由で Cygwin Perl を起動するには、 .Rprofile にこう書く
## Sys.setenv(PATH=paste0(c("C:\\cygwin64\\bin", Sys.getenv("PATH")), sep="", collapse=";"))

## .Rprofile は環境変数 R_USER のディレクトリに置くが、
## 環境変数 R_USER の値は C:\Users\Username\Documents がデフォルトのようだが、
## 私の環境では HOME と同じ=C:\Home\Username である。
```

## 準備

[R](https://cran.r-project.org/bin/windows/base/) と [RStudio](https://rstudio.com/products/rstudio/) をインストールする。そのあと必要なパッケージをインストールする。

```{r install, eval=FALSE, echo=TRUE}
install.packages("assertthat")
install.packages("functional")
install.packages("extrafont")
install.packages("plotly")
install.packages("rlang")
install.packages("tidyverse")
install.packages("RColorBrewer")
```

```{r setup, eval=FALSE, echo=FALSE}
## 各コードチャンクを逐次実行するとき実行する
library(assertthat)
library(functional)
library(extrafont)
library(rlang)
library(tidyverse)
library(RColorBrewer)
```

以下のコードをRStudioのConsoleに順に入力して実行する。Rスクリプトを実行するときは、拡張 .R のファイルにコードを書いて、シェルからRscriptを起動する。

## プログラミング言語Rの基本

### 基本型

基本型として、とりあえず 論理型(logical : Pythonのbool)、数値(numeric)、文字列 (character) を知っておけばよい。characterは文字列で、文字型は無い。文字コードはUnicode、エンコードは UTF-8 一択。Shift_JIS はもう忘れよう。

論理型の、真はTRUE、偽はFALSE という定数である。全部大文字である。整数と真理値を足すとき、TRUEは1に、FALSEは0として扱う。Python の 2 + True と、R の 2 + TRUE はどちらも 3 になる。

まずPythonの実行結果を示す。

```{python add_int_bool_python, result="asis"}
2 + True
```

次にRの実行結果を示す。出力の先頭に [1] がついているが、これについては後述する。

```{r add_int_bool_r}
2 + TRUE
```

NA (欠測値 : missing value)と、変数が無い(NULL)ことを区別する。変数がNAかどうかは is.na で、NULLかどうかは in.null で調べる(細かい仕様は省略)。

```{r is_na}
is.na(0)
is.na(NA)
is.null(0)
is.null(NULL)
```

一般的にNAとの計算結果はNAになる。この点は、C++の boost::tribool に近い。

```{r na_tribool}
TRUE & NA
TRUE | NA
FALSE & NA
FALSE | NA
```

NAは logical, numeric, character と、それぞれの型に用意されている。実は logical -> numeric -> character という変換は、必要なら暗黙に行われるので、あまり気にしなくてよい。さっきの 2 + TRUE がそうだった。

数値が NA (欠測値)、正の無限大 Inf、負の無限大 -Inf、NaN (非数 : Not a Number)なことは区別する。is.na, is.infinite, is.nan を使って調べる。 == では比較しないことに注意する。RはNAとNaNを区別するので便利である(入力値が欠測なことと、計算結果がNaNであることは別なので)。

```{r is_inf_nan}
is.infinite(0)
is.infinite(Inf)
Inf > 0
is.infinite(-Inf)
-Inf < 0
is.nan(0)
is.nan(NaN)
```

関数の説明は、? + 関数名で得られる。R Consoleから ?is.na と入力すると、 is.na の説明が表示される。ネットで探すよりも速い。

```{r help_is_nan, eval=FALSE, echo=TRUE}
?is.na
```

Rにスカラー変数はない。C++の std::vector てきな集合、つまり型が等しい複数の要素を、インデックスで参照できる集合が、ベクトルとして用意されている。なのでスカラー変数に見えるものは、要素が1個のベクトルである。変数への代入は \<- で行う。Getsと発音する。Pythonと同様に=でも代入できるが、 \<- の方が見やすいだろう。

```{r assign_int}
n <- 2
n * 3
```

複数の即値つまりからベクトルを作るには、 c(15, 26, 37, 48) というようにc()を使う。cはcombineの略である。ベクトルというか配列を作るのに[]を使う言語が多いのでちょっと変わっているが、すぐ慣れるだろう。

```{r assign_vector}
score_vec <- c(15, 26, 37, 48)
name_vec <- c("foo", "bar", "hoge")
score_vec
name_vec
```

出力の [1] は、この行はベクトルの1番目から順番に表示している、という意味である。さっきから [1] が必ず表示されていたのは、要素が1個のベクトルを表示していたからである。要素がたくさんあるベクトルを表示すると行を折り返すので、そのときは1より大きい数字になる。

ベクトルに限らず、配列らしくインデックスがついているデータ(PandasのDataFrameてきなものも含む)の要素は、1始まりで数える。つまりベクトルvの先頭の要素は、 v[1] で読み書きする。PythonやCなど多くの言語は0始まりだが、Rは異なる(FortranやStanも1始まり)。

```{r vector_element}
score_vec[1]
name_vec[2]
```

Pythonと同様、複数の値を指定することもできる。

```{r vector_elements}
score_vec[c(1, 4)]
```

負の値を指定すると、指定したインデックス以外を選ぶ。つまり除外するインデックスを指定することができる。

```{r vector_exclude_elements}
score_vec[c(-2, -3)]
```

0を指定すると何も選ばない。PythonやC++の癖で、先頭要素を0にするとこうなる。敢えて0を含めることで条件分岐を省けることがあるかもしれない。

```{r vector_no_elements}
score_vec[0]
```

ベクトル同士はcで結合する。

```{r concat_vectors}
c(c(1, 2, 3), c(4, 5))
```

### 演算

Rにスカラー変数はなく、ベクトルはあるので、演算はベクトル同士の演算になる。まず足し算 c(10, 20, 30) + c(4, 5, 6) は、要素ごとの和になる。これは要素が1個のベクトル 10 + 4 = 14 の拡張と考えれば素直だろう。

```{r add_vectors}
c(10, 20, 30) + c(4, 5, 6)
10 + 4
```

max()は、ベクトルの要素のうち、もっとも大きい値を返す。max(c(10, 20, 30)) は c(30) 、つまり要素が1個のベクトルである。さっきの足し算がmapなら、maxはreduceと考えると解りやすいだろう。

```{r max_vector}
max(c(10, 20, 30))
```

2つのベクトルの要素ごとのmaxを取りたい、つまりmapしたいなら、pmaxを使う。

```{r pmax_vectors}
pmax(c(10, 2, 30), c(4, 50, 6))
```

NumPyてきなbroadcastingを、Rでも行うことができる。 c(10, 20, 30) + 4 は c(14, 24, 34) になる。左辺のそれぞれに4を足すというふるまいは直観的だろう。実際には右辺ベクトルの要素を、左辺ベクトルの要素数と同じになるまで繰り返している(repeat)。

```{r add_vector_int}
c(10, 20, 30) + 4
```

ちなみに同じ値を繰り返したければ、repを使う。

```{r repeat_vector_int}
rep(4, 3)
```

### ベクトルの要素数とrange

要素数はNROW()で調べる。length()もあるが忘れていい。

```{r length_vector_int}
NROW(c(10, 20, 30))
NROW(4)
NROW(c())
```

Pythonのrangeてきな連番を作ろう。要素数n個のベクトルvに対して 1, 2, ..., n という連番の整数は、 seq_len(n) で作る。seq_len(NROW(c(10, 20, 30)))は要素が3個なのでc(1, 2, 3)になる。seq_len(NROW(c()))は空ベクトルが返る。Pythonと異なりRは閉区間であり、区間の開始と終了の両方を要素に含む。

```{r seq_len_vector_int}
seq_len(NROW(c(10, 20, 30)))
seq_len(NROW(4))
seq_len(NROW(c()))
```

続きは[等差数列](#number_sequence)の項で説明する。

### リスト

型が混在する集合はlistに格納する。Pythonのlist、C言語の構造体と似ている。 "" が無い箇所があることに注意する。

```{r list}
a_lst <- list(name = "foo", score = 80, year = 2019)
a_lst
NROW(a_lst)
names(a_lst)
```

要素には$名前、[[属性名]]、インデックスでアクセスできる。Pythonのenumerableな感じだ。

```{r list_elements}
a_lst$score
a_lst[["score"]]
a_lst[[2]]
```

一重カッコ [属性名] は、要素ではなくリストを返す。

```{r sublist}
a_lst["score"]
a_lst[2]
is.list(a_lst["score"])
is.list(a_lst[["score"]])
```

ベクトルと同様に、インデックスを指定して部分リストを得ることができる。属性名を指定してもよい。

```{r sublists}
a_lst[1:2]
a_lst[c("name", "score")]
```

リスト同士はcで結合する。Pythonもそうだが、リストを長くするのか、リストにリストを入れて入れ子にするのかで、コードを使い分ける必要がある。

こちらはリストを長くする。

```{r concat_lists}
list_1 <- list("foo")
list_2 <- list(80)
list_3 <- list(2019)
list_3_elements <- c(list_1, list_2, list_3)
list_3_elements
NROW(list_3_elements)
```

こちらはリストを入れ子にする。

```{r nested_lists}
nested_list <- list(first = list_1, second = list_2)
nested_list
```

要素の型がすべて同じリストは、 unlist でベクトルに変換することができる。逆も然りで、 as.list を使ってベクトルをリストにする。後で説明するが、Rでは一般的に as.型名 で型変換を行う。

identicalは、二つのオブジェクトが同値ならTRUE、違っていたらFALSEを返す。identicalといいつつ、同一オブジェクト(雑に言うと同じメモリ番地に置かれている)かどうかではなく、値が同じかどうかを調べる。

```{r vectors_from_to_lists}
original_vec <- 1:5
list_from_vec <- as.list(original_vec)
converted_vec <- unlist(list_from_vec)
assertthat::assert_that(identical(original_vec, converted_vec))
```

### DataFrame (tibble)

```{r import_tidyverse}
library(tidyverse)
```

PandasのDataFrameと同様に、Rにもdata.frameがある(Rが先だったかもしれないが)。だがtibbleというもっといいものがあるのでそちらを使う。まず説明用の架空データを作る。

```{r create_tibble}
df <- tibble(name = c("foo", "bar"), score = c(80, 60), year = c(2019, 2020))
```

```{r embed_tibble, eval=TRUE, echo=FALSE}
df %>% kable() %>% kable_styling()
```

print()すると今作った tibble を文字列として表示する。というより実は、変数名だけ入力するとprint()して表示していたのだった。PythonのREPLと同じである。

```{r print_tibble}
print(df)
```

View()するとExcelっぽいウィンドウに表示する。ここには表示できないので、各自試してほしい。

```{r view_tibble, eval=FALSE, echo=TRUE}
View(df)
```

tibbleは、縦方向(行)が標本、横方向(列)が標本の属性である。ざっくりいうと、縦に長いベクトルを横に並べたものがtibbleと思えばよい。なので、先のリストの動作がそのまま当てはまる。

まず score のベクトルを取得する。Pandasがそうであるように、tibbleは連想配列らしく使える。ベクトルが返るのでPandasのSeriesとは少し異なる。

```{r extract_column_as_vector}
df$score
df[["score"]]
df[[2]]
```

scoreだけを切り出したtibbleを取得する。

```{r extract_column_as_tibble}
df["score"]
df[2]
```

行=標本も指定しよう。この記法はNumPyっぽく、Pandasのようにlocとは書かない。

```{r extract_cell}
df[[1, "score"]]
df[1, "score"]
```

行=標本を指定して全属性を取り出すときは、 , の後を空白にする。 : は書かない。

```{r extract_sample}
df[1, ]
```

ここでは一列ずつ、一行ずつ取り出したが、リストと同様に複数の要素を取り出すこともできる。


### Matrix

tibbleに比べれば覚えることが少ないので、最低限のことだけ説明する。

tibbleと異なり、すべての要素を同じ型にする。まずベクトルから行列を作る。

```{r create_matrices}
matrix(data = 1:6, nrow = 2, byrow = FALSE)
matrix(data = 1:6, nrow = 2, byrow = TRUE)
```

要素がすべて型の同じtibbleから行列を作る。

```{r tibble_to_matrix}
df_num <- tibble(p=1:2, q=3:4, r=5:6)
mat_num <- as.matrix(df_num)
mat_num
```

as_tibbleでtibbleに変換する。

```{r matrix_to_tibble}
df_mat_num <- as_tibble(mat_num)
df_mat_num
assertthat::assert_that(identical(df_num, df_mat_num))
```

### 関数

Rの関数は、Pythonのラムダ式である。

Pythonでは以下のように、引数の2乗を返す無名関数を定義して、それをmy_squareという変数に格納し、こう呼び出せる。

```{python lambda_python, result="asis"}
my_square = lambda n: n * n
my_square(9)
```

Rではfunctionと書く。

```{r lambda_r}
my_square <- function(n) { n * n }
my_square(9)
```

Pythonと同様に、引数にキーワードをつけてもよい。引数が多いときは、キーワードをつけるとソースコードが読みやすくなるだろう。

```{r keyword_parameters}
my_square(n = 9)
```

Pythonと同様に、引数のキーワードありとなしを混在することもできる。まずキーワードがある引数を当てはめ、残りのパラメータをまだ値が無い先頭のパラメータから順に当てはめる。

```{r named_parameters}
my_pow <- function(base, index) {
  base**index
}
my_pow(index = 2, 3)
```

do.callを使って、Pythonのunpack, Rubyのsplatのように、listを引数に展開することもできる。

```{r splat_parameters}
args <- list(base = 3, index = 2)
do.call(my_pow, args)
```

さて、Rの関数はすべて式(expression)である。関数が最後に評価したこと(雑に言うと{}の最後の行)が関数の返り値になる。関数定義の途中で処理を終えるのでなければ、returnと明示する必要ない(この辺はRubyっぽい)。

Rで負の数の対数を取ると、警告を出してNaNを返すが、代わりに-Infを返す関数を作ろう。ifも式なのでこう書ける。

```{r if_expression}
my_log10 <- function(x) {
  if (x <= 0) {
    -Inf
  } else {
    log10(x)
  }
}

log10(-1)
my_log10(-1)
my_log10(0)
my_log10(0.1)
my_log10(10)
```

最初に述べた通り、Rにスカラー変数はないので、この引数xはベクトルである。ならば、ベクトルを受け取ってベクトルを返すmap動作がRらしいだろう。PythonのPythonicに対応する言葉が、R-likeである。上記のコードがどうなるか試してみよう。

```{r naive_my_log}
my_log10(c(-1, 0, 0.1, 10))
```

上手くいってないようだ。改善方法は二つある。一つ目の方法は、ifelseを使って、ベクトルの要素ごとにthenとelseを選ぶことだ。ただしこれは、log10(負の値)が警告を出すので、見た目がよろしくない。警告ではなくエラーになる関数では使えないだろう。

```{r if_else_log}
my_log10_alt1 <- function(xs) {
  ifelse(xs <= 0, -Inf, log10(xs))
}
my_log10_alt1(c(-1, 0, 0.1, 10))
```

二つ目の方法は、Pythonの list comprehension てきにmapすることだ。このようにmapを使いこなすとよいだろう。

```{r map_else_log}
my_log10_alt2 <- function(xs) {
  purrr::map_dbl(xs, function(x) {
    if (x <= 0) {
      -Inf
    } else {
      log10(x)
    }
  })
}
my_log10_alt2(c(-1, 0, 0.1, 10))
```

Rでfor文は使わないので、忘れてよい。Pythonでfor文を使う処理があったら、常にmapとreduceを使うことを検討しよう。mapの例の次に、reduceの使い方として、フィボナッチ数列を示そう。0と負の数についてはエラーになるが、それでいいだろう。

```{r reduce_fib}
my_fib <- function(xs) {
  purrr::map_dbl(xs, function(x) {
    tail(purrr::reduce(.x = seq_len(x), .init = integer(), function(acc, i) {
      if (i == 1) {
        c(1)
      } else if (i == 2) {
        c(1, 1)
      } else {
        c(acc[2], sum(acc))
      }
    }), 1)
  })
}

my_fib(1:10)
```

Pythonで外の lexical scope にある変数を変更するには、nonlocalを使う。以下のコードでは、outer()は1を返す。

```{python nonlocal_python, result="asis"}
def outer():
  z = 0
  def inner():
     nonlocal z
     z = z + 1
     return -2
  inner()
  return z

outer()
```

Rでは \<\<- を使って、 lexical scope の外にある変数に代入する。

```{r nonlocal_r}
outer <- function() {
  z <- 0
  inner <- function() {
     z <<- z + 1
     -2
  }
  inner()
  z
}

outer()
```

PythonもRも、lexical scopeの範囲は、ざっくりいうと関数(defやfunction)である。なので関数が入れ子になっている場合は、nonlocalが必要になることがある。C++は if (cond) {} や何もキーワードがつかない {} も自動変数の範囲と寿命を決めているが、Rはそうではないので注意する(ifなどはスコープを変えない)。

tibbleの説明に書いたように、関数呼び出しの結果はコンソールに表示される。そのままだと大量に出力でコンソールが埋まって困ることがあるだろう。関数の結果を変数で受け止めるのが一つの方法だが、もう一つの方法は関数呼び出しの結果を invisible() で受け止めることである。

いかにもわざとらしい例だが、以下の関数は要素がn個のベクトルを返し、先頭からn個(通常は1000個で打ち切り)を表示しようとするが、 invisible があると何も表示しない。

```{r invisible}
n_element_vector <- function(n) {
  1:n
}
```

```{r launch_invisible}
invisible(n_element_vector(n = 2000))
```

## いろいろな処理と込み入った話題

### 文字列処理

Rでは文字列の整形をするには、昔ながらのsprintfを使う。

```{r sprintf}
sprintf("地点=%s, 温度=%.1f", "横浜", 11.8)
```

文字列を連結するときは、pasteを使う。sep引数が文字列の区切り文字で、デフォルトは半角空白1個である。英語で英単語を連結して文を作るときはこれでよいが、日本語では困ることがあるだろう。区切り文字を空文字列にするにはsep引数で明示的に指定するか、paste0を使う。Rの文字列は + 演算子で連結できない。

```{r paste}
paste("神奈川県", "横浜市", "中区")
paste("神奈川県", "横浜市", "中区", sep = " ")
paste0("神奈川県", "横浜市", "中区")
paste("神奈川県", "横浜市", "中区", sep = ":")
```

以下のコードは意外にも、要素が3個のベクトルを返す。pasteはベクトルをベクトルにmapする関数である。

```{r paste_map}
words <- c("神奈川県", "横浜市", "中区")
paste(words)
```

collapseを指定すると、文字列を区切り文字で連結して、単一の文字列を返す。reduceな動作になる。

```{r paste_reduce}
paste(words, sep = "", collapse = ":")
```

より高度な文字列処理はstringrパッケージを使う。PythonもRもたくさんの関数があるが、代表的なものとして正規表現で文字列を分解する例を示そう。Python の re は full matching 、R の stringr は partial matching である。

```{python str_match_pythoon, eval=TRUE, result="asis"}
import re
re.match(r".{2}(\D+)(\d+)", "01Year2021").groups()
```

```{r str_match_r}
stringr::str_match("01Year2021", "(\\D+)(\\d+)")
```

### 強制型変換

既に書いたが、logical, numeric, character の右側への変換は、必要なら暗黙に行われる。paste関数で試そう。書式を指定しなければ、よきに計らった文字列表記になる。

```{r coerce_paste}
paste("Bool", exp(1), 2, FALSE)
```

リストとベクタの変換で既に示したように。型変換は一般に as.型名 でできる。Rは変数名に . を含めることができ、PythonやC++でインスタンスメソッドの前に . をつけるときのような特別な意味は . にはない。

```{r coerce_numeric}
as.numeric("-2.7")
as.integer("-2.7")
as.character(-2.7)
```

無限大と文字列に書くことができる。Pythonのfloat()と同じである。こちらがPythonで

```{python coerce_inf_python}
float("Inf")
float("-infinity")
```

こちらがRである。

```{r coerce_inf_r}
as.numeric("Inf")
as.numeric("-infinity")
```

型変換できないときは、警告を出してNAが返る。Pythonと違って、エラーにはならない。

```{python coerce_not_a_number_python, error=TRUE}
float("abc")
```

```{r coerce_not_a_number_r}
as.numeric("abc")
```

NAは後でどうにかするので警告を無視したいなら、 suppressWarnings() を使う。

```{r suppress_warnings}
suppressWarnings(as.numeric("abc"))
```

### 等差数列 {#number_sequence}

Pythonのrangeと同様のことをしたければ、 seq() とか 1:n とかがある。ただしPythonのrangeと異なり、開始番号が終了番号より小さいと、1ずつ減る数列が得られる。ベクトルのインデックスを得る場合に、これだと空のベクトルのインデックスがc(1, 0)になってまずい。seq_len()を積極的に使おう。

```{r seq_vector}
seq(4)
1:4
seq(0)
1:0
seq(-2)
1:-2
```

さて差が整数ではない等差数列は、丸め誤差が発生するので、予想した長さにならないことがある。以下はPythonのコードである。NumPy.linspaceは数列の長さを指定するので正しい個数になるが、NumPy.arrangeは丸め誤差の影響で個数が合わないことがある。

```{python linspace_python}
import numpy as np
for x in range(50, 53):
  print("{} {}".format(len(np.linspace(0.0, 1.0, x)),
                       len(np.arange(0.0, 1.0, 1.0/(x - 1)))))
```

同様のことを、Rではseqの length.out引数と、by引数で区別する。この例ではPythonと違って丸め誤差の影響を受けなかったが、両引数を使い分ける必要がある。

```{r linspace_r}
purrr::map_chr(50:52, function(x) {
  sprintf("%d %d", NROW(seq(from = 0.0, to = 1.0, length.out = x)),
                   NROW(seq(from = 0.0, to = 1.0, by = 1.0 / (x - 1))))
})
```

### Assertion

Pythonでは、()をつけずにassertを書く。

```{python assert_python, result="asis"}
assert 2 ** 4 == 16
```

```{python assertion_failed_python, error=TRUE, result="asis"}
assert 2 ** 4 != 16
```

Rではassertthatを使う。パッケージを使う前にimportするのは、Pythonと同様である。

```{r assert_r}
library(assertthat)
assertthat::assert_that((2**4) == 16)
```

```{r assertion_failed_r, error=TRUE}
assertthat::assert_that((2**4) != 16)
```

### 日時と時刻

日時(date)と時刻(timestamp)を上手く扱うのは難しいので、よくできたパッケージを上手に使いこなす。一年の初めからどれだけの割合(0..1)が経過したか指定すると、その日時を表示する関数を作る。うるう年は考慮するがうるう秒は考慮しない。[1月4日のお昼には、もう2021年の「1%」が経過している](https://twitter.com/kuina_ch/status/1344513191707963392)のは本当だろうか?

```{r elapsed_time_in_year}
elapsed_time_in_year <- function(year, ratio) {
  epoch <- paste0(year, "-01-01 00:00:00")
  x <- lubridate::ymd_hms(epoch, tz = "Asia/Tokyo")
  x + lubridate::dseconds((365 + lubridate::leap_year(x)) * 24 * 60 * 60 * ratio)
}

elapsed_time_in_year(year=2021, ratio=0.01)
elapsed_time_in_year(year=2020, ratio=0.01)
elapsed_time_in_year(year=2021, ratio=0.162)
elapsed_time_in_year(year=2020, ratio=0.162)
```

時間(duration)を説明するついでに関数合成しよう。functional::Composeは二つの関数を合成する。ここでは hh:mm:ss 書式の時間の文字列を受け取って、何秒か返す関数を作る。 function を使っても同じことをできるが、引数とか書かなくて済むのですっきりする。

```{r hms_to_seconds}
library(functional)
hms_to_seconds <- functional::Compose(lubridate::hms, lubridate::seconds)
```

```{r launch_hms_to_seconds}
hms_to_seconds("00:01:04")
hms_to_seconds("01:00:04")
```

### 参照渡しと copy-on-modify

Rでは、呼び出された関数は引数を変更できるが、その変更は呼び出し側には伝わらない。これはPythonとの大きな違いである。より正確に言うと、引数を変更するとcopy-on-modifyされる。変更しなければcopyのコストが発生しないので、実質的には低コストな参照渡しのように動作する。

Pythonで、配列の要素をすべて2倍にするとき、こう書ける。

```{python double_python}
import numpy as np

def doubler(x):
  for i, item in enumerate(x):
    x[i] = item * 2
  print(np.sum(x))

v = np.ones(10)
doubler(v)
v
```

rで同様のコードを書くとどうなるだろうか? 忘れていたfor文を敢えて使って書こう。

```{r double_for_r}
doubler <- function(x) {
  for (i in 1:NROW(x)) {
    x[i] = x[i] * 2
  }
  print(sum(x))
}

v <- rep(1, 10)
doubler(v)
v
```

doublerの中では二倍になったようだが(和が20なので)、呼び出し元の変数vは変わらなかった。これがcopy-on-modifyである。

Rでは引数を上書きすることは諦めて、値を返す関数を素直にmapで書こう。"~ .x * 2" は無名関数の略記法である。今は深入りしないが、いずれ役に立つことがあるだろう。

```{r double_map_r}
doubler <- function(x) {
  purrr::map_dbl(x, ~ .x * 2)
}

doubler(rep(1, 10))
```

### デフォルト値

Pythonで関数呼び出しに失敗した場合にデフォルト値を得ようとしたら、try-except構文を使うだろう。Rではpurrr::possiblyを使って、デフォルト値を返す関数を作る。 stop はエラーを発生させる関数である。

```{r possibly, error=TRUE}
suspicious_func <- function(x) {
  stop("Unsupported")
}

safe_func <- purrr::possibly(suspicious_func, NA)
safe_func(1)
```

変数が存在するかどうかは、Pythonでは、locals() と globals() を調べると分かる。

```{python check_vars_python, result="asis"}
a_glogal_var = 1
def check_vars_exists():
  a_local_var = 2
  assert "a_glogal_var" in globals()
  assert "a_local_var" in locals()
  assert "missing_var" not in locals()

check_vars_exists()
```

Rでは exists で分かる。

```{r check_vars_r}
a_glogal_var <- 1
check_vars_exists <- function() {
  a_local_var <- 2
  assertthat::assert_that(exists("a_glogal_var")) &
  assertthat::assert_that(exists("a_local_var")) &
  assertthat::assert_that(!exists("missing_var"))
}

check_vars_exists()
```

Pythonと同様にデフォルト引数を書くこともできる。だがデフォルト引数がいつ評価されるかは、PythonでもRでも厄介な問題を生むので、個人的にはお勧めしない。以下はPythonでありがちなバグである。

```{python default_python, result="asis"}
def add(x=[]):
  x.append(1)
  return x

add()
add()
add()
```

Rのデフォルト引数も、Pythonと同様である。

```{r default_r}
real_to_complex <- function(real, imaginary = 0.0) {
  list(r = real, im = imaginary)
}

real_to_complex(real = 1)
real_to_complex(real = 1, imaginary = 2)
```

引数が無いことは missing で分かる。NULLを指定することと、引数が無いことは異なる。この例ならデフォルト引数を使っても大差ないが、引数が無いことが分かるとできることがあるかもしれない。

```{r missing_r}
real_to_complex_alt <- function(real, imaginary) {
  im_part <- if (missing(imaginary)) {
     0
  } else {
     imaginary
  }
  list(r = real, im = im_part)
}

real_to_complex_alt(real = 1)
real_to_complex_alt(real = 1, imaginary = 2)
real_to_complex_alt(real = 1, imaginary = NULL)
```

関数のデフォルト引数の値を調べるために、Pythonでは inspect.signature を使う。Rではformalsを使う。以下は正規表現で文字列を分割する関数のデフォルト引数である。

```{python inspect_python, result="asis"}
import inspect
inspect.signature(re.split)
```

```{r inspect_r}
formals(stringr::str_split)
```

### コマンドライン引数を解析する

コマンドライン引数は、commandArgs()で文字列ベクトルとして取得する。 trailingOnly=FALSE にするとすべての引数、 trailingOnly=TRUE にすると --args および以降の引数(--argsがなければ空文字列ベクトル)を取得する。R処理系に渡す引数を無視して、Rスクリプトだけに渡す引数を取得するために、 trailingOnly=TRUE を使うとよい。

```{r command_args, eval=FALSE, echo=TRUE}
commandArgs(trailingOnly=FALSE)
commandArgs(trailingOnly=TRUE)
```

```{r launch_command_args, eval=TRUE, echo=FALSE}
commandArgs(trailingOnly=FALSE) %>% purrr::discard(~ stringr::str_detect(.x, "\\.Rmd"))
commandArgs(trailingOnly=TRUE)
```

コマンドライン引数のオプションを解析するのは、Pythonではargparseを使い、Rではoptparseを使うとよいだろう。両者はほとんど同じである。

R MarkdownをHTML化したときの引数を出したが、 R Markdown ファイルの場所がフルパスで見えてしまうのは削除した。

## CSVファイルを読んで集計する

Rの基本が分かったので、CSVファイルをRで読み込んで描画しよう。Rにはサンプルデータがあってそれを使うのが定番であるが、そういう描画例はウェブで多数見つかるのと、Pythonで同じデータを描画できることを目的に、横浜市のオープンデータを使用する(詳細は[データ出典](#data_source) )。

本R Markdown文書にはデータを添付しないので、R MarkdownからHTMLを生成する場合は、各自ダウンロードして、 **incoming_yokohama** サブフォルダに置くこと。ウェブ上のデータは更新されているので、実行時期によって結果が変わるかもしれない。

|内容とリンク先|更新日|ファイル名|
|:------------------------------|:------------------------------|:------------------------------|
|[人口と世帯数の推移](https://www.city.yokohama.lg.jp/city-info/yokohamashi/tokei-chosa/portal/opendata/jinko-setai-suii.html)|最新版(2020年まで)|jinkosetai-sui.csv|
|[男女別人口及び世帯数－行政区](https://www.city.yokohama.lg.jp/city-info/yokohamashi/tokei-chosa/portal/opendata/suikei01.html)|令和2年9月(2020年9月)|e1yokohama2009.csv|

### CSVファイルを読む

readr::read_csv を使う。

```{r read_csv}
library(tidyverse)
df_timeseries <- readr::read_csv("incoming_yokohama/jinkosetai-sui.csv")
```

```{r table_timeseries, echo=FALSE}
df_timeseries %>% head() %>% kable() %>% kable_styling()
```

さてprintで表示すると、列名に `` がついているのが分かる。

```{r print_timeseries}
print(df_timeseries)
```

これは列名に ( を含むので、$の後に列名を書けないということである。

```{r print_timeseries_column_error, error=TRUE}
df_timeseries$年（和暦）
```

という風に、 ( が上手く構文解析できないのでエラーになってしまった。このように構文中に埋め込む名前として使えるものを syntactic name 、そうでないものを non-syntactic name と呼ぶ。詳しい解説は[Advanced R](https://adv-r.hadley.nz/names-values.html)にあるが、ここでは間にあわせの回避策だけ述べよう。

一つ目は、列名を ` (backtick)で囲むことである。

```{r print_timeseries_column_correct}
df_timeseries$`年（和暦）`
```

二つ目は、列名を colnames で付け替えることである。もちろん入力するデータがどんな形式か分かっていて、それぞれの列に対応する名前をつける。

```{r rename_timeseries_column_correct}
colnames(df_timeseries) <- c("JPyear", "Year", "Household", "Population")
```

```{r renamed_table_timeseries, echo=FALSE}
df_timeseries %>% head() %>% kable() %>% kable_styling()
```

### グラフを描く

まず単純なグラフを描こう。横軸を年(西暦)、縦軸を人口の折れ線グラフを描く。たった3行で済む。

```{r draw_table_timeseries}
library(ggplot2)
g <- ggplot(df_timeseries)
g <- g + geom_line(aes(x = Year, y = Population))
plot(g)
```

いろいろと見た目を変えたり、要素を付け加えることもできる。詳しくは [R for Data Science](https://r4ds.had.co.nz/data-visualisation.html)に例がたくさんある。

- 折れ線の色を青くして太くする
- X軸の刻みを10年間隔にする
- タイトルをつける
- 背景を白にする
- 高さを幅の0.6倍にする
- フォントを Segoe UI にして、フォントのサイズを指定する

```{r make_breaks}
year_unit <- 10
x_min <- ceiling(min(df_timeseries$Year) / year_unit) * year_unit
x_max <- floor(max(df_timeseries$Year) / year_unit) * year_unit
x_breaks <- unique(c(min(df_timeseries$Year),
  seq(from = x_min, to = x_max, by = year_unit), max(df_timeseries$Year)))
x_head <- head(x_breaks, 2)
x_tail <- tail(x_breaks, 2)
x_breaks <- setdiff(x_breaks,
  c(x_head[2 * (diff(x_head) < year_unit)], x_tail[1 * (diff(x_tail) < year_unit)]))
```

```{r draw_fancy_table_timeseries, message=FALSE}
library(extrafont)
font_name <- "Segoe UI"
g <- ggplot(df_timeseries)
g <- g + geom_line(aes(x = Year, y = Population), color = "navy", size = 2)
g <- g + scale_x_continuous(breaks = x_breaks)
g <- g + ggtitle("Yokohama Population")
g <- g + theme_bw()
g <- g + theme(aspect.ratio = 0.6,
               text = element_text(family = 16),
               axis.text = element_text(family = font_name, size = 12),
               axis.title = element_text(family = font_name, size = 16),
               plot.title = element_text(family = font_name, size = 20))
plot(g)
```

tibbleの列名は英語にしても、図の表示は日本語にしたいということがあるだろう。 Migu 1M フォントで表示する。

```{r draw_jp_table_timeseries}
font_name <- "Segoe UI"
font_name_jp <- "Migu 1M"
g <- ggplot(df_timeseries)
g <- g + geom_line(aes(x = Year, y = Population), color = "navy", size = 2)
g <- g + scale_x_continuous(breaks = x_breaks)
g <- g + ggtitle("横浜市の人口")
g <- g + xlab("年(西暦)")
g <- g + ylab("人口")
g <- g + theme_bw()
g <- g + theme(aspect.ratio = 0.6,
               text = element_text(family = font_name),
               axis.text = element_text(family = font_name_jp, size = 12),
               axis.title = element_text(family = font_name_jp, size = 16),
               plot.title = element_text(family = font_name_jp, size = 20))
plot(g)
```

plotly::ggplotlyを使うと、インタラクティブに拡大縮小したり、線にカーソルを置いて各年の人口を表示できたりする。

```{r plotly_jp_table_timeseries, message=FALSE, warning=FALSE}
library(plotly)
plotly::ggplotly(g)
```

図をPNGファイルに保存するには、 ggsaveを使う。

```{r ggsave_png, message=FALSE}
ggsave("yokohama_population.png", plot = g, dpi = 160)
```

png() と dev.off() で囲んでもよいが、その場合は高さと幅のピクセル数を固定する必要がある。縦横比を変えたくないときはうれしくないだろう。

```{r save_png, message=FALSE}
png(filename = "yokohama_population.png", width = 800, height = 600)
g <- ggplot(df_timeseries)
g <- g + geom_line(aes(x = Year, y = Population))
plot(g)
dev.off()
```

### CSVファイルを加工する

Pandasてきに、CSVファイルを加工する方法を説明する。横浜市各区の人口を読み込む。その後、列名を英語にする。

```{r read_wards}
df_population_data <- readr::read_csv("incoming_yokohama/e1yokohama2009.csv")
print(colnames(df_population_data))
colnames(df_population_data) <- c("date", "code", "ward", "area",
                                  "household", "population", "male", "female",
                                  "per_household", "density",
                                  "diff_household", "diff_population")
```

```{r print_wards, eval=FALSE, echo=FALSE}
## 表示すると、列が長すぎて画面からはみ出しているかもしれない。それと先頭行は区ではなく、横浜市の合計である。
df_population_data %>% kable() %>% kable_styling()
```

今後使いそうな列だけ残して、後は削除する。列を選ぶには dplyr::select を使う。 %>% は、コマンドラインのパイプと同様、前段で処理したデータを後段に流す。この書き方に慣れるとRが好きになるだろう。実際には前段の返り値を後段の第一引数にしており、Pandasのメソッドチェーン(method chaining)と同じである。

```{r select_wards}
df_population <- df_population_data %>%
  dplyr::select(c("ward", "area", "household", "population", "per_household", "density"))
```

```{r print_selected_wards, echo=FALSE}
df_population %>% kable() %>% kable_styling()
```

横浜市の合計と各区を分離しよう。 dplyr::filter を使って、～区とそれ以外を抜き出す。str_endは文字列がある文字列で終わっているかどうかをTRUEまたはFALSEで返す。Pythonの endswith と同じである。

```{r separate_wards}
df_wards <- df_population %>%
  dplyr::filter(stringr::str_ends(ward, "区"))

df_all_city <- df_population %>%
  dplyr::filter(!stringr::str_ends(ward, "区"))
```

もしくはこう書ける。

```{r separate_wards_alt, eval=FALSE}
df_population %>% dplyr::filter(ward != "横浜市")
```

```{r print_all_city, echo=FALSE}
df_all_city %>% kable() %>% kable_styling()
```

dplyr::select は列名を文字列で指定したが、dplyr::filter の ward は "" が無いので文字列ではない。これは先ほど説明したシンボル(symbol)である。今回のように各区はwardという列にある、と分かっているときはこのようにハードコーディングしてよいが、実行時に文字列で与えたいことがあるだろう。そのときは !!rlang::sym を使う。

```{r import_rlang, message=FALSE, warning=FALSE}
library(rlang)
```

```{r separate_wards_again}
ward_column_name <- "ward"
df_wards_alt <- df_population %>%
  dplyr::filter(!!rlang::sym(ward_column_name) != "横浜市")
assertthat::assert_that(identical(df_wards, df_wards_alt))
```

rlang::expr を使って、 !!rlang::sym がどう展開されたかを確認すると、先ほどのコードと同じことが分かる。

```{r separate_wards_expanded}
rlang::expr(df_population %>%
  dplyr::filter(!!rlang::sym(ward_column_name) != "横浜市"))
```

実は　dplyr::select は、文字列だけでなくシンボルを受け付ける。なので "" が無くてもよかった。わざとらしい例だが、複数の文字列をシンボルにするには、 rlang::syms を使う。それと、!!ではなく!!!を使う。!!と!!!は否定の否定、否定の否定の否定、ではなく演算子というのが珍しい。

```{r select_wards_again}
column_names <- c("ward", "area", "household", "population", "per_household", "density")
df_population_alt <- df_population_data %>%
  dplyr::select(!!!rlang::syms(column_names))
assertthat::assert_that(identical(df_population, df_population_alt))
```

### それぞれの行を集計する

df_wards には、 1世帯当たり人員[人] (per_household 列)と 人口密度[人/平方キロメートル] (density 列)がある。これらは、人口(population 列)、世帯数(household 列) 、面積(area 列)から計算できる。 dplyr::mutate で実際に計算して列を作ろう。

```{r mutate_wards}
df_wards_calc <- df_wards %>%
  dplyr::mutate(per_household_calc = population / household, density_calc = population / area)
```

元データの per_household と計算で求めた per_household_calc 、元データの density と計算で求めた density_calc が等しいか確認しよう。浮動小数が丸め誤差を除いて大体同じかどうかは、 dplyr::near で許容誤差 tol を与えて比べる。dplyr::near は二つの要素を先頭から順に比較して、大体同じ=TRUE、違う=FALSEというベクトルを返す。全部TRUEかどうかはallで分かる。

```{r near_calc}
assertthat::assert_that(all(dplyr::near(x = df_wards_calc$per_household,
  y = df_wards_calc$per_household_calc, tol = 0.01)))
assertthat::assert_that(all(dplyr::near(x = df_wards_calc$density,
  y = df_wards_calc$density_calc, tol = 1.0)))
```

計算した1世帯当たり人員と人口密度があっていたようだ。

ちなみに dplyr::mutate の代入先もシンボルであり、実行時に文字列を与えるときは rlang::sym を使う。このときは = ではなく := を使う。代入元がシンボルの場合も同様である。

```{r mutate_wards_sym}
dst_column_name <- "per_household_calc"
df_wards_calc_dst <- df_wards %>%
  dplyr::mutate(!!rlang::sym(dst_column_name) := population / household)
assertthat::assert_that(all(dplyr::near(df_wards_calc$per_household_calc,
                                        df_wards_calc_dst$per_household_calc)))

src1_column_name <- "population"
src2_column_name <- "household"
df_wards_calc_src <- df_wards %>%
  dplyr::mutate(per_household_calc :=
    !!rlang::sym(src1_column_name) / !!rlang::sym(src2_column_name))
assertthat::assert_that(all(dplyr::near(df_wards_calc$per_household_calc,
                                        df_wards_calc_src$per_household_calc)))
```

### それぞれの列を集計する

全区の世帯数と人口を足して、横浜市全体 df_all_city と同じかどうか確かめる。

```{r sum_wards}
df_wards_sum <- df_wards_calc %>%
  dplyr::summarize_at(c("household", "population"), sum)
```

```{r print_sum_wards, echo=FALSE}
df_wards_sum %>% kable() %>% kable_styling()
```

```{r verify_sum}
assertthat::assert_that(df_all_city$household == df_wards_sum$household)
assertthat::assert_that(df_all_city$population == df_wards_sum$population)
```

各区の合計は市全体と一致したようだ。

ここでは世帯数と人口を足したが、それは区の名前、1世帯当たり人員、人口密度を足しても意味が無いからである。そして面積は足していなかった。列名を挙げるのがめんどくさければ、列が数字だったら足す、という操作をしたい。そういうときは、 dplyr::summarize と across を使う。1世帯当たり人員と人口密度を除いてから、数値つまり区の名前以外の列を足す。

```{r sum_wards_all}
df_wards_sum_all <- df_wards %>%
  dplyr::select(-c("per_household", "density")) %>%
  dplyr::summarize(across(where(is.numeric), sum))
```

面積もあっているようだ。

```{r verify_sum_all}
assertthat::assert_that(dplyr::near(x = df_all_city$area, y = df_wards_sum_all$area, tol = 1.0))
```

### 行をグループ化する

グループ化の例として、横浜市各区を [税務署の管轄地域](https://www.nta.go.jp/about/organization/tokyo/location/kanagawa.htm)でまとめよう。まず税務署と区の対応表を作る。

```{r tax_offices}
tax_offices <- c("神奈川", "神奈川", "鶴見", "戸塚", "戸塚", "戸塚", "保土ケ谷",
  "保土ケ谷", "保土ケ谷", "緑", "緑", "緑", "横浜中", "横浜中",
  "横浜南", "横浜南", "横浜南", "横浜南")
ward_names <- c("神奈川区", "港北区", "鶴見区", "戸塚区", "栄区", "泉区",
  "保土ケ谷区", "旭区", "瀬谷区", "緑区", "青葉区", "都筑区", "中区", "西区",
  "南区", "磯子区", "金沢区", "港南区")
df_tax_offices <- tibble(tax_office = tax_offices, ward = ward_names)
```

区の名前で結合する。Rには連想配列がないが、tibbleで連想配列てきなテーブルを作ればよい。連想配列の要素を個々に引くより、 inner join や left join する方が手軽である。

```{r join_tax_offices}
df_ward_tax_offices <- dplyr::inner_join(df_tax_offices, df_wards, by = "ward")
```

税務署ごとに世帯数と人口をまとめよう。dplyr::group_by を使って、行をグループ化できる。それぞれのグループについて、列ごとにすべての行を足す。

```{r group_tax_offices}
df_group_population <- df_ward_tax_offices %>%
  dplyr::select(c("household", "population", "tax_office")) %>%
  dplyr::group_by(tax_office) %>%
  dplyr::summarize(across(everything(), sum)) %>%
  dplyr::ungroup()
```

```{r print_group_tax_offices, echo=FALSE}
df_group_population %>% kable() %>% kable_styling()
```

鶴見が少ないのは鶴見区しかないからだが、横浜中も少ない。おそらく人口の割に事業所が多いからだと予想するが、実際そうなっているか確認するのは読者への課題とする。ちなみに衆議院選挙小選挙区は区や市をまたぐので、今回の目的には使えなかった。

### カテゴリ変数

グループに用いた税務署名は文字列である。これをカテゴリ値にすることができる。Rではカテゴリをfactorと呼ぶ。 as.factor で文字列をカテゴリに変換する。

```{r factor_tax_offices}
df_factor <- df_ward_tax_offices %>%
  dplyr::mutate(tax_office = as.factor(tax_office))
```

カテゴリを表示すると、見た目は文字列のままだが、実際は文字列に対応する整数を振ったものだと分かる。

```{r print_facotr_tax_offices}
df_factor$tax_office
as.integer(df_factor$tax_office)
```

カテゴリの整数の番号を固定したいことがある。例えばグラフの凡例を描くとき、凡例はカテゴリの整数が小さい順(1, 2, ...)に表示される。 forcats::fct_relevel を使うと、整数の順番を固定できる。

カテゴリの順番を五十音順にしよう。つまり、神奈川(かながわ)、鶴見(つるみ)、戸塚(とつか)、保土ケ谷(ほどがや)、緑(みどり)、横浜中(よこやまなか)、横浜南(よこはまみなみ)の順にする。

```{r relevel_tax_offices}
df_factor <- df_ward_tax_offices %>%
  dplyr::mutate(tax_office = as.factor(tax_office)) %>%
  dplyr::mutate(tax_office = forcats::fct_relevel(tax_office,
    c("神奈川", "鶴見", "戸塚", "保土ケ谷", "緑", "横浜中", "横浜南")))
df_factor$tax_office
as.integer(df_factor$tax_office)
```

先ほどとは整数の割り当てが異なる。図にしたとき、凡例が五十音順になることを確かめよう。

```{r draw_relevel_tax_offices}
library(RColorBrewer)
font_name <- "Segoe UI"
font_name_jp <- "Migu 1M"
g <- ggplot(df_factor)
g <- g + geom_point(aes(x = per_household, y = density, color = tax_office), size = 4, shape = 4)
g <- g + geom_text(aes(x = per_household, y = density, label = ward),
  nudge_x = -0.03, size = 2)
g <- g + scale_color_manual(values = brewer.pal(NROW(unique(df_factor$tax_office)), "Dark2"))
g <- g + ylim(0, 16000)
g <- g + xlab("1世帯当たり人員[人]")
g <- g + ylab("人口密度[人/平方キロメートル]")
g <- g + guides(color = guide_legend(title = "税務署"))
g <- g + theme_bw()
g <- g + theme(aspect.ratio = 0.8,
               text = element_text(family = font_name_jp),
               legend.position = "right",
               legend.text = element_text(family = font_name_jp, size = 16),
               legend.title = element_text(family = font_name_jp, size = 16),
               axis.text = element_text(family = font_name, size = 16),
               axis.title = element_text(family = font_name, size = 14),
               strip.text = element_text(family = font_name, size = 20),
               plot.title = element_text(family = font_name, size = 20))
plot(g)
```

facet_wrap(~ tax_office, nrow=2) と一行追加するだけで、カテゴリ別の表を作る。ggplot2すごい。

```{r facet_wrap_relevel_tax_offices}
g <- ggplot(df_factor)
g <- g + geom_point(aes(x = per_household, y = density, color = tax_office), size = 4, shape = 4)
g <- g + geom_text(aes(x = per_household, y = density, label = ward),
  nudge_x = -0.03, size = 2)
g <- g + scale_color_manual(values = brewer.pal(NROW(unique(df_factor$tax_office)), "Dark2"))
g <- g + ylim(0, 16000)
g <- g + xlab("1世帯当たり人員[人]")
g <- g + ylab("人口密度[人/平方キロメートル]")
g <- g + guides(color = guide_legend(title = "税務署"))
g <- g + theme_bw()
g <- g + facet_wrap(~tax_office, nrow = 2)
g <- g + theme(aspect.ratio = 0.8,
               text = element_text(family = font_name_jp),
               legend.position = "none",
               axis.text = element_text(family = font_name, size = 9),
               axis.title = element_text(family = font_name, size = 10),
               strip.text = element_text(family = font_name, size = 12),
               plot.title = element_text(family = font_name, size = 12))
plot(g)
```

### CSVファイルを出力する

readr::write_excel_csv を使って、BOMつきUTF-8でCSVファイルを書く。こうしておくとExcelで読める(BOMがないとExcelで読めない)。Pandasと同様、gzip形式で読み書きできる。

```{r write_group_tax_offices}
readr::write_excel_csv(df_ward_tax_offices, path = "yokohama_tax_office.csv")
readr::write_excel_csv(df_ward_tax_offices, path = "yokohama_tax_office.csv.gz")
```

### JSONファイルを読み書きする

CSVファイルには、それがどんなデータかというメタデータを記述しづらい。メタデータをJSONファイルに書くとよいだろう。例えば横浜市と茅ヶ崎市について、このように書く。city:漢字名、kana:かな表記、roman:ローマ字表記、designated:政令指定都市かどうか、n_wards:政令指定都市なら区の数、tax_offices:所管税務署、date:最終更新日、とする。

```{text data_yokohama}
{
    "city" : "横浜市",
    "kana" : "よこはま",
    "roman" : "Yokohama",
    "designated" : true,
    "n_wards" : 18,
    "tax_offices" : ["神奈川", "鶴見", "戸塚", "保土ケ谷", "緑", "横浜中", "横浜南"],
    "date": "2021/01/01"
}
```

```{text data_chigasaki}
{
    "city" : "茅ヶ崎市",
    "kana" : "ちがさき",
    "roman" : "Chigasaki",
    "designated" : false,
    "tax_offices" : "藤沢",
    "date": "2021/01/01"
}
```

```{r read_jsons}
data_yokohama <- jsonlite::fromJSON("incoming_metadata/r_in_30min_yokohama.json")
print(data_yokohama)
data_chigasaki <- jsonlite::fromJSON("incoming_metadata/r_in_30min_chigasaki.json")
print(data_chigasaki)
class(data_chigasaki)
```

JSONファイルをリストとして読み込んだことが分かる。Rにはスカラー変数が無いので、要素(リスト構造の末端)はすべてベクトルである。論理型、数値、文字列型が上手く推測されたことが分かる。日付は必要なら変換しよう。

```{r json_date}
data_yokohama$date <- lubridate::ymd(data_yokohama$date)
data_yokohama$date
class(data_yokohama$date)
```

存在しない要素を取得するとNULLが返る。エラーにはならない。茅ヶ崎市は政令指定都市ではないので、区の数はNULLである。

```{r json_elements}
data_yokohama$n_wards
data_chigasaki$n_wards
```

JSONファイルを書き出してみる。

```{r write_jsons}
jsonlite::write_json(data_yokohama, "output_yokohama.json", pretty=TRUE)
```

出力結果はこうなる。要素が1個でも配列になるのが、以下にもRらしい。

```{text output_yokohama}
{
  "city": ["横浜市"],
  "kana": ["よこはま"],
  "roman": ["Yokohama"],
  "designated": [true],
  "n_wards": [18],
  "tax_offices": ["神奈川", "鶴見", "戸塚", "保土ケ谷", "緑", "横浜中", "横浜南"],
  "date": ["2021-01-01"]
}
```

## その他ツール

### Jupyter Notebook と R Markdown

Pythonでコードを試しながら書く場合、Jupyter Notebook を使っている方が多いだろう。Jupyter Notebook とRという組み合わせも可能である。もう一つの選択肢は、 R Markdown である。まさにこの文書の元は R Markdown で、それをHTMLまたはPDFに変換したものを見ているはずである。

### コードの整形と静的解析

Pythonのコードは、 autopep8 で整形して、pylint, pep8, flake8 でコードの問題点を静的解析して指摘するだろう(他にもツールがあるかもしれない)。

Rは styler パッケージでコードを整形して、 lintr パッケージでコードの問題点を静的解析して指摘するとよい。 styler はRスクリプト(.Rファイル)だけでなく、R Markdown (.Rmdファイル)も整形できる。

lintr で問題点を挙げるとき、スクリプトが完成してから lintr を通すと大量の問題点を指摘されて降参しかねないので、毎日細かく通すとよい。CI (Continuous Integration)を使っているなら、毎登録(git push)ごとにすればよい。もちろん lintr の前に、 styler で自動的に整形することもできる。

lintr よくある指摘は以下の通りである。

- Cyclomatic complexity が大きすぎる。関数が複雑すぎて、理解もテストもできないだろう。小さな関数に分割して、Cyclomatic complexity を減らす。 pylint だと、関数が長い、分岐が多いといった類似の指摘事項が出る。
- 1:NROW(aTibble) は、aTibble が空行のときに誤動作する。代わりに seq_len(NROW(aTibble)) を使う。このようによくある間違ったイディオムを指摘する。Pythonでは、 range(len(anObj))の代わりに enumrate(anObj) を使え、と指摘されることがある。
- ローカル変数が使われていない。似たような変数と取り違えているか、本当に使われなくなった変数が残っているかどちらかなので対処する。変数は要らなくても、そも変数を返す関数呼び出しは必要かもしれない。
- 書式の良し悪し、例えば = の前後に空白をいれるかどうかは、 styler に任せて手作業で直さない。
- 変数名に対する指摘は、仕方ない場合もある。指摘に対応しないこともしばしばある。

### コードの論理行数

cloc パッケージで、ファイルの論理行、コメント行、空行を数えることができる。Rだけでなくさまざまなプログラミング言語に対応している。Perlが必要なので、Windows の場合は perl (Cygwin可)にPATHを通しておく。ファイル名だけでなくURLを指定することもできる。[R pasteNumbers Addin](https://github.com/zettsu-t/pasteNumbers)にあるファイルの行数を測ろう。

```{r cloc, eval=FALSE, echo=TRUE}
library(cloc)
cloc::cloc(source = "pasteNumbers.R")
```

実行結果は下記の通りである。

|source        |language |file_count |file_count_pct |loc |loc_pct |blank_lines |blank_line_pct |comment_lines |
|:-------------|:--------|:----------|:--------------|:---|:-------|:-----------|:--------------|:-------------|
|pasteNumbers.R|R        |1          |0.5            |15  |0.5     |1           |0.5            |28            |

## 次に進むには

最初に[データサイエンス100本ノック（構造化データ加工編）](https://github.com/The-Japan-DataScientist-Society/100knocks-preprocess)を解いて、PythonのDataFrameと、Rのtibbleの違いを覚えるとよいでしょう。

参考書としては、以下の順番が一案です。

- 最初に読むのは、Rではじめるデータサイエンス (原著 : [R for Data Science](https://r4ds.had.co.nz/) )
- Rをもっと使いこなすなら、Rクックブック 第2版 ( 原著 : [R Cookbook 2nd Edition](https://rc2e.com/) )
- R StudioとR Markdownの使い方を学ぶなら、再現可能性のすゝめ ―RStudioによるデータ解析とレポート作成― (Wonderful R 3) または、 RユーザのためのRStudio［実践］入門 ―tidyverseによるモダンな分析フローの世界―
- プログラミング言語Rを深く知りたいなら、R言語徹底解説(ただし和訳は版が古い、原著 : [Advanced R](https://adv-r.hadley.nz/) )。 [公式マニュアル](https://cran.r-project.org/manuals.html)より読みやすいと思います。
- Rパッケージの作成を通じて、配布可能な成果物の作り方を学びたいなら、Rパッケージ開発入門 テスト、文書化、コード共有の手法を学ぶ(原著 : [R packages](http://r-pkgs.had.co.nz/) )

|書名|著者|年|リンク|
|:--------------------------|:---------------------------------------------------------|:--------|:--------------------------|
|R for Data Science|Garrett Grolemund and Hadley Wickham|2017|https://r4ds.had.co.nz/|
|R Cookbook 2nd Edition|James (JD) Long and Paul Teetor|2019|https://rc2e.com/|
|Advanced R|Hadley Wickham|2019|https://adv-r.hadley.nz/|
|R packages|Hadley Wickham|2015|http://r-pkgs.had.co.nz/|

|書名|著者|年|出版社|
|:---------------------------------------------------------|:-------------------------------------------------|:---------|:-----------------------------|
|Rではじめるデータサイエンス|Hadley Wickham, Garrett Grolemund 著/黒川利明 訳/大橋真也 監修|2017|オライリー・ジャパン|
|Rクックブック 第2版|J.D. Long, Paul Teetor 著/大橋真也 監訳/木下哲也 訳|2020|オライリー・ジャパン|
|再現可能性のすゝめ ―RStudioによるデータ解析とレポート作成― (Wonderful R 3)|高橋康介 著/石田基広 監修/市川太祐, 高橋康介, 高柳慎一, 福島真太朗, 松浦健太郎 編|2018|共立出版|
|RユーザのためのRStudio［実践］入門 ―tidyverseによるモダンな分析フローの世界―|松村優哉, 湯谷啓明, 紀ノ定保礼, 前田和寛 著|2018|技術評論社|
|R言語徹底解説|Hadley Wickham 著/石田基広, 市川太祐, 高柳慎一, 福島真太朗 訳|2016|共立出版|
|みんなのR 第2版|Jared P. Lander 著/高柳慎一, 津田真樹, 牧山幸史, 松村杏子, 簑田高志 監修|2018|マイナビ出版|
|パーフェクトR|Rサポーターズ 著|2017|技術評論社|
|Rパッケージ開発入門 テスト、文書化、コード共有の手法を学ぶ|Hadley Wickham 著/瀬戸山雅人, 石井弓美子, 古畠敦 訳|2016|オライリー・ジャパン|

## データ出典 {#data_source}

本 R Markdown からHTML文書やPDF文書を生成した場合、 [横浜市のオープンデータ](https://www.city.yokohama.lg.jp/city-info/yokohamashi/tokei-chosa/portal/opendata/) を編集・加工したものが埋め込まれます。これらは [利用条件等](https://www.city.yokohama.lg.jp/city-info/yokohamashi/tokei-chosa/portal/opendata/opendata.html) に記載の、 CC BY 4.0 に基づいています。

## ライセンス

本 R Markdown 文書のライセンスは、この文書がある GitHub レポジトリと同じ、MITライセンスです。いろいろコードを変えて、データや表示がどう変わるかお試しください。

