---
title: "Pythonプログラマが30分で分かるR"
author: "プログラマたんbot"
date: '`r format(Sys.time(), "%Y/%m/%d")`'
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
  pdf_document:
    latex_engine: xelatex
  beamer_presentation:
    pandoc_args:
    - --latex-engine
    - xelatex
header-includes:
  \usepackage{float}
documentclass: bxjsarticle
classoption: xelatex,ja=standard
urlcolor: blue
---

```{r setup_r_packages, include=FALSE}
library(assertthat)
library(kableExtra)
library(reticulate)
```

```{r, echo=FALSE, eval=FALSE}
## WindowsからPythonを起動するには、 .Rprofile にこう書く
## Sys.setenv(PATH=paste0(c("C:\bin\anaconda", Sys.getenv("PATH")), sep="", collapse=";"))
```

## 準備

R と RStudioをインストールする。

## プログラミング言語Rの基本

### 基本型

基本型として、とりあえず 論理型(logical : Pythonのbool)、数値(numeric)、文字列 (character) を知っておけばよい。characterは文字列で、文字型は無い。文字コードはUnicode、エンコードは UTF-8 一択。Shift_JIS はもう忘れよう。

真理値の、真はTRUE、偽はFALSE という定数である。全部大文字である。整数と真理値を足すとき、TRUEは1に、FALSEは0として扱う。Python の 2 + True と、R の 2 + TRUE はどちらも 3 になる。

まずPythonの実行結果を示す。

```{python add_int_bool_python, result="asis"}
2 + True
```

次にRの実行結果を示す。出力の先頭に [1] についているが、これについては後述する。

```{r add_int_bool_r}
2 + TRUE
```

NA (欠測値 : missing value)と、変数が無い(NULL)ことを区別する。変数がNAかどうかは is.na で、NULLかどうかは in.null で調べる(細かい仕様は省略)。

```{r is_na}
is.na(0)
is.na(NA)
is.null(0)
is.null(NULL)
```

一般的にNAとの計算結果はNAになる。この点は、C++の boost::tribool に近い。

```{r na_tribool}
TRUE & NA
TRUE | NA
FALSE & NA
FALSE | NA
```

NAは logical, numeric, character と、それぞれの型に用意されている。実は logical -> numeric -> character という変換は、必要なら暗黙に行われるので、あまり気にしなくてよい。さっきの 2 + TRUE がそうだった。

数値が NA (欠測値)、正の無限大 Inf、負の無限大 -Inf、NaN (非数 : Not a number)なことは区別する。is.na, is.infinite, is.nan を使って調べる(細かい仕様は省略)。 == では比較しないことに注意する。RはNAとNaNを区別するので便利である(入力値が欠測なことと、計算結果がNaNであることは別なので)。

```{r is_inf_nan}
is.infinite(0)
is.infinite(Inf)
is.infinite(-Inf)
is.nan(0)
is.nan(NaN)
```

Rにスカラー変数はない。C++の std::vector 的な集合、つまり型が等しい複数の要素を、インデックスで参照できる集合が、ベクトルとして用意されている。なのでスカラー変数に見えるものは、要素が1個のベクトルである。変数への代入は \<- で行う。getsと発音する。Pythonと同様に=でも代入できるが、 \<- の方が見やすいだろう。

```{r assign_int}
n <- 2
n * 3
```

複数の即値つまりからベクトルを作るには、 c(15, 26, 37, 48) というようにc()を使う。cはcombineの略である。[]を使う言語が多いのでちょっと変わっているが、慣れればそういうもの。

```{r assign_vector}
int_vec <- c(15, 26, 37, 48)
name_vec <- c("foo", "bar", "hoge")
int_vec
name_vec
```

出力の [1] は、この行はベクトルの1番目から順番に表示している、という意味である。さっきから [1] が必ず表示されていたのは、要素が1個のベクトルを表示していたからである。

ベクトルに限らず、配列らしくインデックスがついているデータ(PandasのDataFrameてきなものも含む)の要素は、1始まりで数える。つまりベクトルvの先頭の要素は、 v[1] で読み書きする。PythonやCなど多くの言語は0始まりだが、Rは異なる(FortranやStanも1始まり)。

```{r vector_element}
int_vec[1]
name_vec[2]
```

Pythonと同様、複数の値を指定することもできる。

```{r vector_elements}
int_vec[c(1, 4)]
```

負の値を指定すると、指定したインデックス以外を選ぶ。つまり除外するインデックスを指定することができる。

```{r vector_exclude_elements}
int_vec[c(-2, -3)]
```

0を指定すると何も選ばない。PythonやC++の癖で、先頭要素を0にするとこうなる。敢えて0を含めることで条件分岐を省けることがあるかもしれない。

```{r vector_no_elements}
int_vec[0]
```

### 演算

Rにスカラー変数はなく、ベクトルはあるので、演算はベクトル同士の演算になる。まず足し算 c(10, 20, 30) + c(4, 5, 6) は、要素ごとの和になる。これは要素が1個のベクトル 10 + 4 = 14 の拡張と考えれば素直だろう。

```{r add_vectors}
c(10, 20, 30) + c(4, 5, 6)
```

max()は、ベクトルでもっとも大きい値を返す。max(c(10, 20, 30)) は c(30) 、つまり要素が1個のベクトルである。さっきの足し算がmapなら、maxはreduceと考えると解りやすいだろう。

```{r max_vector}
max(c(10, 20, 30))
```

NumPyてきなbroadcastingを、Rでも行うことができる。 c(10, 20, 30) + 4 は c(14, 24, 34) になる。左辺のそれぞれに1を足すというふるまいは直観的だろう。実際には右辺ベクトルの要素を、左辺ベクトルの要素数と同じになるまで繰り返している(repeat)。

```{r add_vector_int}
c(10, 20, 30) + 4
```

### ベクトルの要素数とrange

要素数はNROW()で調べる。length()は忘れていい。

```{r length_vector_int}
NROW(c(10, 20, 30))
NROW(4)
NROW(c())
```

Pythonのrangeてきな連番を作ろう。要素数n個のベクトルvに対して 1, 2, ..., n という連番の整数は、 seq_len(n) で作る。seq_len(NROW(c(10, 20, 30)))は要素が3個なのでc(1, 2, 3)になる。seq_len(NROW(c()))は空ベクトルが返る。Pythonと異なり、Rは閉区間=区間の開始と終了を要素に含む。

```{r seq_len_vector_int}
seq_len(NROW(c(10, 20, 30)))
seq_len(NROW(4))
seq_len(NROW(c()))
```

Pythonのrangeと同様のことをしたければ、 seq() とか 1:n とかがある。ただしPythonのrangeと異なり、開始番号が終了番号より小さいと、1ずつ減る数列が得られる。これだと空文字のベクトルのインデックスがc(1, 0)になりまずいので、seq_len()を使おう。

```{r seq_vector}
seq(4)
1:4
seq(0)
1:0
seq(-2)
1:-2
```

ベクトル同士はcで結合する。

```{r concat_vectors}
c(1:3, 4:6, 7:9)
```

### リスト

型が混在する集合はlistに格納する。Pythonのlist、C言語の構造体と似ている。 "" が無い箇所があることに注意する。

```{r list}
a_lst <- list(name="foo", score=80, year=2019)
a_lst
NROW(a_lst)
names(a_lst)
```

要素には$名前、[[属性名]]、インデックスでアクセスできる。Pythonのenumerableな感じだ。

```{r list_elements}
a_lst$score
a_lst[["score"]]
a_lst[[2]]
```

一重カッコ [属性名] は、要素ではなくリストを返す。

```{r sublist}
a_lst["score"]
a_lst[2]
is.list(a_lst["score"])
is.list(a_lst[["score"]])
```

ベクトルと同様に、インデックスを指定して部分リストを得ることができる。属性名を指定してもよい。

```{r sublists}
a_lst[1:2]
a_lst[c("name", "score")]
```

リスト同士はcで結合する。Pythonもそうだが、リストを長くするのか、リストにリストを入れて入れ子にするのかで、コードを使い分ける必要がある。

こちらは

```{r concat_lists}
list_1 <- list("foo")
list_2 <- list(80)
list_3 <- list(2019)
list_3_elements <- c(list_1, list_2, list_3)
list_3_elements
NROW(list_3_elements)
```

```{r nested_lists}
nested_list <- list(first=list_1, second=list_2)
nested_list
```

要素の型がすべて同じリストは、ベクトルに変換することができる。逆も然り。Rは変数名に . を含めることができ、PythonやC++でインスタンスメソッドの前に . をつけるときのような特別な意味は . にはない。

```{r vectors_from_to_lists}
original_vec <- 1:5
list_from_vec <- as.list(original_vec)
converted_vec <- unlist(list_from_vec)
assertthat::assert_that(identical(original_vec, converted_vec))
```

### DataFrame

まず必要なパッケージをインストールする。

```{r install, eval=FALSE, echo=TRUE}
winstall.packages("tidyverse")
```

パッケージを使う前にimportするのは、Pythonと同様である。

```{r import_tidyverse}
library(tidyverse)
```

PandasのDataFrameと同様に、Rにもdata.frameがある(Rが先だったかもしれないが)。だがtibbleというもっといいものがあるのでそちらを使う。まずダミーデータを作る。

```{r create_tibble}
df <- tibble(name=c("foo", "bar"), score=c(80, 60), year=c(2019, 2020))
```

```{r embed_tibble, eval=TRUE, echo=FALSE}
df %>% kable() %>% kable_styling()
```

print()すると今作った tibble を文字列として表示する。というより実は、変数名だけ入力するとprint()して表示していたのだった。PythonのREPLもそうでしょ。

```{r print_tibble}
print(df)
```

View()するとExcelっぽいウィンドウに表示する。ここには表示できないので、各自試してほしい。

```{r view_tibble, eval=FALSE, echo=TRUE}
View(df)
```

DataFrameは、縦方向(行)が標本、横方向(列)が標本の属性である。ざっくりいうと、縦に長いベクトルを横に並べたものがtibbleと思えばよい。なので、先のリストの動作がそのまま当てはまる。

まず score のベクトルを取得する。PandasのSeriesとは少し異なる。

```{r extract_column_as_vector}
df$score
df[["score"]]
df[[2]]
```

scoreだけを切り出したtibbleを取得する。

```{r extract_column_as_tibble}
df["score"]
df[2]
```

行=標本も指定しよう。この記法はNumPyっぽく、Pandasのようにlocとは書かない。

```{r extract_cell}
df[[1, "score"]]
df[1, "score"]
```

行=標本を指定して全属性を取り出すときは、 , の後を空白にする。 : は書かない。

```{r extract_sample}
df[1, ]
```

ここでは一列ずつ、一行ずつ取り出したが、リストと同様に複数の要素を取り出すこともできる。


### 関数

Rの関数は、Pythonのラムダ式である。

Pythonでは以下のように、引数の二乗を返す無名関数を定義して、それをmy_squareという変数に格納し、こう呼び出せる。

```{python lambda_python, result="asis"}
my_square = lambda n: n * n
my_square(9)
```

Rではfunctionと書く。

```{r lambda_r}
my_square <- function(n) { n * n }
my_square(9)
```

```{r keyword_parameters}
my_square(n=9)
```

Pythonと同様に、引数のキーワードありとなしを混在することもできる。まずキーワードがある引数を当てはめ、残りのパラメータをまだ値が無い先頭のパラメータから順に当てはめる。

```{r named_parameters}
my_pow <- function(base, index) {
  base ** index
}
my_pow(index=2, 3)
```

do.callを使って、Pythonのunpack, Rubyのsplatのように、名前付きlistを引数に展開することもできる。

```{r splat_parameters}
args <- list(base=3, index=2)
do.call(my_pow, args)
```




さて、Rの関数はすべて式(expression)である。関数が最後に評価したこと(雑に言うと{}の最後の行)が関数の返り値になる。関数定義の途中で処理を終えるのでなければ、returnと明示する必要ない(この辺はRubyっぽい)。

Rで負の数の対数を取ると警告を出してNaNを返すが、代わりに-Infを返す関数を作ろう。ifも式なのでこう書ける。

```{r if_expression}
my_log10 <- function(x) {
  if (x <= 0) {
    -Inf
  } else {
    log10(x)
  }
}

log10(-1)
my_log10(-1)
my_log10(0)
my_log10(0.1)
my_log10(10)
```

最初に述べた通り、Rにスカラーはないので、この引数xはベクトルである。ならば、ベクトルを受け取ってベクトルを返すのがRっぽい(R-like)だろう。上記のコードがどうなるか試してみよう。

```{r naive_my_log}
my_log10(c(-1, 0, 0.1, 10))
```

上手くいってないようだ。改善方法は二つある。一つ目の方法は、ifelseを使って、ベクトルの要素ごとにthenとelseを選ぶことだ。ただしこれは、log10(負の値)が警告を出すので、見た目がよろしくない。警告ではなくエラーになる関数では使えないだろう。

```{r if_else_log}
my_log10_alt1 <- function(xs) {
  ifelse(xs <= 0, -Inf, log10(xs))
}
my_log10_alt1(c(-1, 0, 0.1, 10))
```

二つ目の方法は、Pythonの list comprehension てきに写像(map, inject)することだ。このようにmapを使いこなすとよいだろう。

```{r map_else_log}
my_log10_alt2 <- function(xs) {
  purrr::map_dbl(xs, function(x) {
    if (x <= 0) {
      -Inf
    } else {
      log10(x)
    }
  })
}
my_log10_alt2(c(-1, 0, 0.1, 10))
```

Rでfor文は使わないので、忘れてよい。Pythonでfor文を使う処理があったら、常にmapとreduceを使うことを検討しよう。上記の通りmapは書いたので、reduceの使い方として、フィボナッチ数列を示そう。0と負の数についてはエラーになるが、それでいいだろう。

```{r reduce_fib}
my_fib <- function(xs) {
  purrr::map_dbl(xs, function(x) {
    tail(purrr::reduce(.x=seq_len(x), .init=integer(), function(acc, i) {
      if (i == 1) {
        c(1)
      } else if (i == 2) {
        c(1, 1)
      } else {
        c(acc[2], sum(acc))
      }
    }), 1)
  })
}

my_fib(1:10)
```

Pythonで、 lexical scope の外にある変数を変更するには、nonlocalを使う。以下のコードでは、outer()は1を返す。

```{python nonlocal_python, result="asis"}
def outer():
  z = 0
  def inner():
     nonlocal z
     z = z + 1
     return -2
  inner()
  return z

outer()
```

Rでは \<\<- を使って、 lexical scope の外にある変数に代入する。

```{r nonlocal_r}
outer <- function () {
  z <- 0
  inner <- function () {
     z <<- z + 1
     -2
  }
  inner()
  z
}

outer()
```

PythonもRも、lexical scopeの範囲は、ざっくりいうと関数(defやfunction)である。なので関数が入れ子になっている場合は、nonlocalが必要になることがある。C++はif{}や何もキーワードがつかない {} も自動変数の範囲と寿命を決めているが、Rはそうではないので注意すること(ifなどはスコープを変えない)。

## いろいろな処理と込み入った話題

### 文字列処理

Rでは文字列の整形をするには、昔ながらのsprintfを使う。

```{r sprintf}
sprintf("地点=%s, 温度=%.1f", "横浜", 11.8)
```

文字列を連結するときは、pasteを使う。sepが文字列の区切り文字であるが、デフォルトは半角空白1個である。区切り文字を~文字列にするには明示的にしているか、paste0を使う。Rの文字列は + 演算子で連結できない。

```{r paste}
paste("神奈川県", "横浜市", "中区")
paste0("神奈川県", "横浜市", "中区")
paste("神奈川県", "横浜市", "中区", sep=":")
```

以下のコードは意外にも、要素が3個のベクトルを返す。pasteはベクトルをベクトルにmapする関数である。

```{r paste_map}
words <- c("神奈川県", "横浜市", "中区")
paste(words)
```

collapseを指定すると、文字列を区切り文字で連結して、単一の文字列を返す。

```{r paste_reduce}
paste(words, sep="", collapse=":")
```

より高度な文字列処理はstringrパッケージを使う。PythonもRもたくさんの関数があるが、代表的なものとして正規表現で文字列を分解する例を示そう。

```{python str_match_pythoon, eval=TRUE, result="asis"}
import re
re.match(r"(\D+)(\d+)", "Year2021").groups()
```

```{r str_match_r}
stringr::str_match("Year2021", "(\\D+)(\\d+)")
```

### 強制型変換

既に書いたが、logical, numeric, character の右側への変換は、必要なら暗黙に行われる。paste関数で試そう。書式を指定しなければ、よきに計らった文字列表記になる。

```{r coerce_paste}
paste("Bool", exp(1), 2, FALSE)
```

リストとベクタの変換で既に示したように。型変換は一般に as.型名 でできる。

```{r coerce_types}
as.numeric("-2.7")
as.integer("-2.7")
as.character(-2.7)
```

### 参照渡しと copy-on-modify

Rでは、呼び出された関数は引数を変更できるが、その変更は呼び出し側には伝わらない。これはPythonとの大きな違いである。より正確に言うと、引数を変更するとcopy-on-modifyされる。変更しなければcopyのコストが発生しないので、実質的には低コストな参照渡しのように動作する。

Pythonで、配列の要素をすべて2倍にするとき、こう書ける。

```{python double_python}
import numpy as np

def doubler(x):
  for i, item in enumerate(x):
    x[i] = item * 2
  print(np.sum(x))

v = np.ones(10)
doubler(v)
v
```

rで同様のコードを書くとどうなるだろうか? 忘れていたfor文を敢えて使って書こう。

```{r double_for_r}
doubler <- function(x) {
  for (i in 1:NROW(x)) {
    x[i] = x[i] * 2
  }
  print(sum(x))
}

v <- rep(1, 10)
doubler(v)
v
```

doublerの中では二倍になったようだが(和が20なので)、呼び出し元の変数vは変わらなかった。これがcopy-on-modifyである。

Rでは引数を上書きすることは諦めて、値を返す関数を素直にmapで書こう。"~ .x * 2" は無名関数の略記法である。いずれ役に立つことがあるだろう。

```{r double_map_r}
doubler <- function(x) {
  purrr::map_dbl(x, ~ .x * 2)
}

doubler(rep(1, 10))
```

### Assertionとデフォルト値

Pythonでは、()をつけずにassertを書く。

```{python assert_python, result="asis"}
assert 2 ** 4 == 16
```

```{python assertion_failed_python, error=TRUE, result="asis"}
assert 2 ** 4 != 16
```

Rではassertthatを使う。

```{r assert_r}
library(assertthat)
assertthat::assert_that((2 ** 4) == 16)
```

```{r assertion_failed_r, error=TRUE}
assertthat::assert_that((2 ** 4) != 16)
```

Pythonで関数呼び出しに失敗した場合にデフォルト値を得ようとしたら、try-except構文を使うだろう。Rではpurrr::possiblyを使って、デフォルト値を返す関数を作る。なお stop はエラーを発生させる関数である。

```{r possibly, error=TRUE}
suspicious_func <- function(x) {
  stop("Unsupported")
}

safe_func <- purrr::possibly(suspicious_func, NA)
safe_func(1)
```

変数が存在するかどうかは、Pythonでは、locals() と globals() を調べると分かる。

```{python check_vars_python, result="asis"}
a_glogal_var = 1
def check_vars_exists():
  a_local_var = 2
  assert "a_glogal_var" in globals()
  assert "a_local_var" in locals()
  assert "missing_var" not in locals()

check_vars_exists()
```

Rでは exists で分かる。

```{r check_vars_r}
a_glogal_var <- 1
check_vars_exists <- function() {
  a_local_var <- 2
  assertthat::assert_that(exists("a_glogal_var")) &
  assertthat::assert_that(exists("a_local_var")) &
  assertthat::assert_that(!exists("missing_var"))
}

check_vars_exists()
```

引数が無いことは missing で分かる。NULLを指定することと、引数が無いことは異なる。この例ならデフォルト引数を使っても大差ないが、引数が無いことが分かるとできることがあるかもしれない。

```{r missing_r}
real_to_complex <- function(real, imaginary) {
  im_part <- if (missing(imaginary)) {
     0
  } else {
     imaginary
  }
  list(r=real, im=im_part)
}

real_to_complex(real=1)
real_to_complex(real=1, imaginary=2)
real_to_complex(real=1, imaginary=NULL)
```

関数のデフォルト引数の値を調べるために、Pythonでは inspect.signature を使う。Rではformalsを使う。以下は正規表現で文字列を分割する関数のデフォルト引数である。

```{python inspect_python, result="asis"}
import inspect
inspect.signature(re.split)
```

```{r inspect_r}
formals(stringr::str_split)
```

### グラフを描く

### CSVを出力する

### コマンドラインのオプションを解析する

Pythonではargparseを使い、Rではoptparseを使うとよいだろう。両者はほとんど同じである。


## その他ツール

### Jupyter Notebook と R Markdown

Pythonでコードを試しながら書く場合、Jupyter Notebook を使っている方が多いだろう。Jupyter Notebook とRという組み合わせも可能である。もう一つの選択肢は、 R Markdown である。まさにこの文書の元は R Markdown で、それをHTMLまたはPDFに変換したものを見ているはずである。

### コードの整形と静的解析

Pythonのコードは、 autopep8 で整形して、pylintk, pep8, flake8 でコードの問題点を静的解析して指摘するだろう(他にもツールがあるかもしれない)。

Rは styler でコードを整形して、 lintr でコードの問題点を静的解析して指摘するとよい。Rスクリプトだけでなく、R Markdown も整形できる。

